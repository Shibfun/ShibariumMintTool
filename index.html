<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="title">Shibarium Mint Tool</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: linear-gradient(135deg, #2c3e50, #34495e); color: #fff; }
        h1 { text-align: center; color: #F4A261; }
        textarea { width: 100%; height: 200px; margin-bottom: 10px; background: #34495E; color: #fff; border-radius: 8px; padding: 10px; }
        button { padding: 10px 20px; background-color: #F4A261; color: white; border: none; cursor: pointer; margin: 5px; border-radius: 8px; transition: background 0.3s, transform 0.2s; }
        button:hover { background-color: #E07A5F; transform: translateY(-2px); }
        #status { margin-top: 10px; white-space: pre-wrap; color: #A8B5D4; }
        .settings { margin: 20px 0; background: rgba(44, 62, 80, 0.9); padding: 15px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); }
        .settings label { display: block; margin-bottom: 10px; color: #fff; }
        .settings input { width: 100%; max-width: 300px; padding: 8px; border-radius: 8px; border: none; background: #34495E; color: #fff; }
        #log { height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; background: rgba(44, 62, 80, 0.9); margin-top: 10px; border-radius: 8px; color: #fff; }
    </style>
</head>
<body onload="updateLanguage()">
    <h1 id="title">Shibarium Mint Tool</h1>
    <div class="settings">
        <label id="labelRpcUrl">Shibarium RPC URL: <input type="text" id="rpcUrl" value="https://www.shibrpc.com"></label>
        <label id="labelChainId">Chain ID: <input type="text" id="chainId" value="109" readonly></label>
        <label id="labelNetworkName">Network Name: <input type="text" id="networkName" value="Shibarium" readonly></label>
        <label id="labelCurrencySymbol">Currency Symbol: <input type="text" id="currencySymbol" value="BONE" readonly></label>
        <label id="labelBlockExplorer">Block Explorer: <input type="text" id="blockExplorer" value="https://www.shibariumscan.io" readonly></label>
        <label id="labelLanguage">Language: <select id="language" onchange="updateLanguage()">
            <option value="en">English</option>
            <option value="zh">中文</option>
        </select></label>
        <label id="labelGasPrice">Gas 价格 (Gwei): <input type="number" id="gasPrice" value="3.2" step="0.1" min="0"></label>
        <label id="labelGasLimit">Gas 限制: <input type="number" id="gasLimit" value="300000" min="21000"></label>
        <label id="labelProcessInterval">处理间隔 (秒): <input type="number" id="processInterval" value="5" min="1"></label>
        <label id="labelMintTimes">铸造次数: <input type="number" id="mintTimes" value="1" min="1" max="100"></label>
    </div>
    <p id="labelPrivateKeys">每行输入一个私钥 (带 "0x" 前缀):</p>
    <textarea id="privateKeys" placeholder="例如:\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"></textarea>
    <button id="mintWowButton" onclick="mintWOW()">铸造 WOW</button>
    <button id="mintSergeButton" onclick="mintSerge()">铸造 Serge</button>
    <button id="mintPnutshibButton" onclick="mintPNUTSHIB()">铸造 PNUTSHIB</button>
    <button id="mintToysButton" onclick="mintToys()">铸造 TOYS</button>
    <button id="mintBoomButton" onclick="mintBOOM()">铸造 BOOM</button>
    <div id="status">状态: 准备就绪</div>
    <div id="log"></div>

    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <script>
        const WOW_CONTRACT_ADDRESS = "0x8f4b11d923BbAA6206f3Dd3ff84e8e31bafB49b7";
        const SERGE_CONTRACT_ADDRESS = "0x9FcEa3627746aEA84c8Eba612E1fD25aC27d605A";
        const PNUTSHIB_CONTRACT_ADDRESS = "0xdE22A4F6C94507898442465d32a03871E4dc11Eb";
        const TOYS_CONTRACT_ADDRESS = "0xB820c8a74c8E4059661460C414821bC5820470D8";
        const BOOM_CONTRACT_ADDRESS = "0x493e6084f9373baF1D9BC85f82c2748a2459083b";
        const MAX_MINT_TIMES = 100;
        const MAX_LOG_ENTRIES = 1000;
        let logQueue = [];

        const WOW_ABI = [{"inputs":[],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"}];
        const SERGE_ABI = [{"inputs":[],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"}];
        const PNUTSHIB_ABI = [{"inputs":[],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"}];
        const TOYS_ABI = [{"inputs":[],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"}];
        const BOOM_ABI = [
            {"inputs":[],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"isWhitelisted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"lastMintBlock","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
        ];

        const messages = {
            en: {
                title: "Shibarium Mint Tool",
                labelRpcUrl: "Shibarium RPC URL: ",
                labelChainId: "Chain ID: ",
                labelNetworkName: "Network Name: ",
                labelCurrencySymbol: "Currency Symbol: ",
                labelBlockExplorer: "Block Explorer: ",
                labelLanguage: "Language: ",
                labelPrivateKeys: "Enter one private key per line (with \"0x\" prefix):",
                privateKeysPlaceholder: "e.g.\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
                labelGasPrice: "Gas Price (Gwei): ",
                labelGasLimit: "Gas Limit: ",
                labelProcessInterval: "Process Interval (seconds): ",
                labelMintTimes: "Mint Times: ",
                statusStarting: "Status: Starting...",
                statusReady: "Status: Ready",
                testingRPC: "Testing RPC connection...",
                connectedToChain: "Connected to chain ID: ",
                expectedChain: " (Shibarium should be 109)",
                chainMismatch: "Error: Not connected to Shibarium network (chain ID should be 109).",
                rpcError: "Error: Failed to connect to RPC: ",
                noPrivateKeys: "Error: No private keys provided.",
                invalidGasPrice: "Error: Invalid Gas Price.",
                invalidGasLimit: "Error: Invalid Gas Limit (minimum 21000).",
                invalidInterval: "Error: Invalid Process Interval (minimum 1 second).",
                invalidMintTimes: "Error: Invalid Mint Times (1-100).",
                processingWallet: "Processing wallet ",
                lowBalanceWarning: "Warning: Wallet ",
                hasLowBalance: " has low BONE balance (",
                mayNotCoverGas: "), may not cover Gas fees.",
                minting: "Minting ",
                for: " for ",
                mintSuccess: "Mint successful! Tx: ",
                errorProcessing: "Error processing ",
                errorMessage: ": ",
                allProcessed: "All wallets processed. Done!",
                generalError: "Error: ",
                notWhitelisted: "Error: Address not whitelisted for BOOM minting: ",
                tooSoonToMint: "Error: Too soon to mint BOOM again, wait for next period: ",
                transactionFailed: "Transaction failed with hash: "
            },
            zh: {
                title: "Shibarium 铸造工具",
                labelRpcUrl: "Shibarium RPC 地址: ",
                labelChainId: "链 ID: ",
                labelNetworkName: "网络名称: ",
                labelCurrencySymbol: "货币符号: ",
                labelBlockExplorer: "区块浏览器: ",
                labelLanguage: "语言: ",
                labelPrivateKeys: "每行输入一个私钥 (带 \"0x\" 前缀):",
                privateKeysPlaceholder: "例如:\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
                labelGasPrice: "Gas 价格 (Gwei): ",
                labelGasLimit: "Gas 限制: ",
                labelProcessInterval: "处理间隔 (秒): ",
                labelMintTimes: "铸造次数: ",
                statusStarting: "状态: 正在启动...",
                statusReady: "状态: 准备就绪",
                testingRPC: "测试 RPC 连接...",
                connectedToChain: "已连接到链 ID: ",
                expectedChain: " (Shibarium 应为 109)",
                chainMismatch: "错误: 未连接到 Shibarium 网络 (链 ID 应为 109)。",
                rpcError: "错误: 无法连接到 RPC: ",
                noPrivateKeys: "错误: 未提供私钥。",
                invalidGasPrice: "错误: 无效的 Gas 价格。",
                invalidGasLimit: "错误: 无效的 Gas 限制 (最小 21000)。",
                invalidInterval: "错误: 无效的处理间隔 (最小 1 秒)。",
                invalidMintTimes: "错误: 无效的铸造次数 (1-100)。",
                processingWallet: "正在处理钱包 ",
                lowBalanceWarning: "警告: 钱包 ",
                hasLowBalance: " 的 BONE 余额低 (",
                mayNotCoverGas: ")，可能无法支付 Gas 费用。",
                minting: "正在铸造 ",
                for: " 为 ",
                mintSuccess: "铸造成功! 交易: ",
                errorProcessing: "处理时出错 ",
                errorMessage: ": ",
                allProcessed: "所有钱包处理完成。完成!",
                generalError: "错误: ",
                notWhitelisted: "错误: 地址未在 BOOM 铸造白名单中: ",
                tooSoonToMint: "错误: BOOM 铸造间隔未到，请等待下一周期: ",
                transactionFailed: "交易失败，哈希: "
            }
        };

        function getMessage(key) {
            return messages[document.getElementById("language").value][key] || key;
        }

        function updateLanguage() {
            document.getElementById("title").textContent = getMessage("title");
            document.getElementById("labelRpcUrl").childNodes[0].textContent = getMessage("labelRpcUrl");
            document.getElementById("labelChainId").childNodes[0].textContent = getMessage("labelChainId");
            document.getElementById("labelNetworkName").childNodes[0].textContent = getMessage("labelNetworkName");
            document.getElementById("labelCurrencySymbol").childNodes[0].textContent = getMessage("labelCurrencySymbol");
            document.getElementById("labelBlockExplorer").childNodes[0].textContent = getMessage("labelBlockExplorer");
            document.getElementById("labelLanguage").childNodes[0].textContent = getMessage("labelLanguage");
            document.getElementById("labelPrivateKeys").textContent = getMessage("labelPrivateKeys");
            document.getElementById("privateKeys").placeholder = getMessage("privateKeysPlaceholder");
            document.getElementById("labelGasPrice").childNodes[0].textContent = getMessage("labelGasPrice");
            document.getElementById("labelGasLimit").childNodes[0].textContent = getMessage("labelGasLimit");
            document.getElementById("labelProcessInterval").childNodes[0].textContent = getMessage("labelProcessInterval");
            document.getElementById("labelMintTimes").childNodes[0].textContent = getMessage("labelMintTimes");
            document.getElementById("mintWowButton").textContent = getMessage("minting") + "WOW";
            document.getElementById("mintSergeButton").textContent = getMessage("minting") + "Serge";
            document.getElementById("mintPnutshibButton").textContent = getMessage("minting") + "PNUTSHIB";
            document.getElementById("mintToysButton").textContent = getMessage("minting") + "TOYS";
            document.getElementById("mintBoomButton").textContent = getMessage("minting") + "BOOM";
            document.getElementById("status").textContent = getMessage("statusReady");
        }

        function log(message) {
            const logDiv = document.getElementById("log");
            logQueue.push({ time: new Date().toLocaleString(), message });
            if (logQueue.length > MAX_LOG_ENTRIES) logQueue.shift();
            logDiv.innerHTML = '';
            const fragment = document.createDocumentFragment();
            logQueue.forEach(({ time, message }) => {
                const p = document.createElement('p');
                p.textContent = `${time}: ${message}`;
                fragment.appendChild(p);
            });
            logDiv.appendChild(fragment);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        async function initializeWeb3() {
            const status = document.getElementById("status");
            const rpcUrl = document.getElementById("rpcUrl").value.trim();
            if (!rpcUrl) {
                status.textContent += getMessage("rpcError") + "Please provide a valid Shibarium RPC URL.\n";
                return null;
            }
            const web3 = new Web3(new Web3.providers.HttpProvider(rpcUrl));
            try {
                status.textContent += getMessage("testingRPC") + "\n";
                const networkChainId = await web3.eth.getChainId();
                status.textContent += getMessage("connectedToChain") + networkChainId + getMessage("expectedChain") + "\n";
                if (networkChainId !== 109) {
                    status.textContent += getMessage("chainMismatch") + "\n";
                    return null;
                }
                return web3;
            } catch (error) {
                status.textContent += getMessage("rpcError") + error.message + "\n";
                return null;
            }
        }

        async function processMint(contractAddress, abi, mintType, isBoom = false) {
            const status = document.getElementById("status");
            status.textContent = getMessage("statusStarting") + "\n";
            const web3 = await initializeWeb3();
            if (!web3) return;
            const contract = new web3.eth.Contract(abi, contractAddress);
            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);
            if (privateKeys.length < 1) {
                status.textContent += getMessage("noPrivateKeys") + "\n";
                return;
            }
            const gasPriceGwei = parseFloat(document.getElementById("gasPrice").value);
            const gasLimit = parseInt(document.getElementById("gasLimit").value);
            const processInterval = parseInt(document.getElementById("processInterval").value) * 1000;
            const mintTimes = parseInt(document.getElementById("mintTimes").value);
            if (isNaN(gasPriceGwei) || gasPriceGwei <= 0) {
                status.textContent += getMessage("invalidGasPrice") + "\n";
                return;
            }
            if (isNaN(gasLimit) || gasLimit < 21000) {
                status.textContent += getMessage("invalidGasLimit") + "\n";
                return;
            }
            if (isNaN(processInterval) || processInterval < 1000) {
                status.textContent += getMessage("invalidInterval") + "\n";
                return;
            }
            if (isNaN(mintTimes) || mintTimes < 1 || mintTimes > MAX_MINT_TIMES) {
                status.textContent += getMessage("invalidMintTimes") + "\n";
                return;
            }
            const gasPriceWei = web3.utils.toWei(gasPriceGwei.toString(), "gwei");
            try {
                for (const pk of privateKeys) {
                    const account = web3.eth.accounts.privateKeyToAccount(pk.trim());
                    web3.eth.accounts.wallet.add(account);
                    status.textContent += getMessage("processingWallet") + account.address + "\n";
                    log(getMessage("processingWallet") + account.address);
                    const balance = await web3.eth.getBalance(account.address);
                    const balanceInBONE = web3.utils.fromWei(balance, "ether");
                    if (balanceInBONE < 0.01) {
                        status.textContent += getMessage("lowBalanceWarning") + account.address + getMessage("hasLowBalance") + balanceInBONE + getMessage("mayNotCoverGas") + "\n";
                        log(getMessage("lowBalanceWarning") + account.address + getMessage("hasLowBalance") + balanceInBONE + getMessage("mayNotCoverGas"));
                        continue;
                    }
                    if (isBoom) {
                        const isWhitelisted = await contract.methods.isWhitelisted(account.address).call();
                        if (!isWhitelisted) {
                            status.textContent += getMessage("notWhitelisted") + account.address + "\n";
                            log(getMessage("notWhitelisted") + account.address);
                            continue;
                        }
                        const lastMintBlock = await contract.methods.lastMintBlock(account.address).call();
                        const currentBlock = await web3.eth.getBlockNumber();
                        if (currentBlock <= parseInt(lastMintBlock) + 16560) {
                            status.textContent += getMessage("tooSoonToMint") + account.address + "\n";
                            log(getMessage("tooSoonToMint") + account.address);
                            continue;
                        }
                    }
                    for (let i = 0; i < mintTimes; i++) {
                        status.textContent += getMessage("minting") + mintType + getMessage("for") + account.address + "...\n";
                        log(getMessage("minting") + mintType + getMessage("for") + account.address);
                        try {
                            const nonce = await web3.eth.getTransactionCount(account.address, "pending");
                            const tx = await contract.methods.mint().send({
                                from: account.address,
                                gas: mintType === "TOYS" ? 6500000 : gasLimit,
                                gasPrice: gasPriceWei,
                                nonce
                            });
                            status.textContent += getMessage("mintSuccess") + tx.transactionHash + "\n";
                            log(getMessage("mintSuccess") + tx.transactionHash);
                        } catch (error) {
                            status.textContent += getMessage("errorProcessing") + account.address + getMessage("errorMessage") + error.message + "\n";
                            log(getMessage("errorProcessing") + account.address + getMessage("errorMessage") + error.message);
                            if (error.receipt && error.receipt.transactionHash) {
                                status.textContent += getMessage("transactionFailed") + error.receipt.transactionHash + "\n";
                                log(getMessage("transactionFailed") + error.receipt.transactionHash);
                            }
                        }
                        await new Promise(resolve => setTimeout(resolve, processInterval));
                    }
                }
                status.textContent += getMessage("allProcessed") + "\n";
                log(getMessage("allProcessed"));
            } catch (error) {
                status.textContent += getMessage("generalError") + error.message + "\n";
                log(getMessage("generalError") + error.message);
            }
        }

        async function mintWOW() {
            await processMint(WOW_CONTRACT_ADDRESS, WOW_ABI, "WOW");
        }

        async function mintSerge() {
            await processMint(SERGE_CONTRACT_ADDRESS, SERGE_ABI, "Serge");
        }

        async function mintPNUTSHIB() {
            await processMint(PNUTSHIB_CONTRACT_ADDRESS, PNUTSHIB_ABI, "PNUTSHIB");
        }

        async function mintToys() {
            await processMint(TOYS_CONTRACT_ADDRESS, TOYS_ABI, "TOYS");
        }

        async function mintBOOM() {
            await processMint(BOOM_CONTRACT_ADDRESS, BOOM_ABI, "BOOM", true);
        }
    </script>
</body>
</html>
